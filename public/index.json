[{"content":"A Beginner\u0026rsquo;s Guide to HTTP Requests\nWhat Are HTTP Requests? HTTP (HyperText Transfer Protocol) is the foundation of communication on the web. When you access a website, your browser sends an HTTP request to the server hosting the site, and the server responds with the requested resources or an error message.\nHTTP requests are categorized into methods, and the server’s response includes status codes indicating the result of the request.\nCommon HTTP Status Codes HTTP status codes are three-digit numbers that inform you about the result of an HTTP request. Here are some commonly encountered codes:\nInformational Responses (1xx): 100: Continue — Indicates the request can proceed. 101: Switching Protocols — The server is switching to a different protocol, as requested. Successful Responses (2xx): 200: OK — The request succeeded, and the server returned the expected response. 201: Created — A resource was successfully created. 204: No Content — The request was successful, but no content is returned. Redirection Responses (3xx): 301: Moved Permanently — The resource is now permanently located at a new URL. 302: Found — Temporary redirection to another URL. Client Error Responses (4xx): 400: Bad Request — The server couldn’t understand the request. 403: Forbidden — The server refuses to fulfill the request. 404: Not Found — The resource couldn’t be found on the server. Server Error Responses (5xx): 500: Internal Server Error — The server encountered an unexpected error. 503: Service Unavailable — The server is temporarily unable to handle the request. HTTP Methods and Their Uses HTTP methods specify the desired action for a resource. Here are the most common methods:\n1. GET Used to retrieve data from a server. GET requests are read-only and do not modify data.\nExample Use Case: Fetching a webpage or retrieving API data.\nimport requests response = requests.get(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;) print(response.json()) 2. POST Used to send data to the server, often for creating resources.\nExample Use Case: Submitting a form or posting a comment.\npayload = {\u0026#34;title\u0026#34;: \u0026#34;New Post\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;This is the content.\u0026#34;, \u0026#34;userId\u0026#34;: 1} response = requests.post(\u0026#39;https://jsonplaceholder.typicode.com/posts\u0026#39;, json=payload) print(response.status_code) # 201 Created 3. PUT Used to update an existing resource. Unlike POST, PUT is idempotent—sending the same request multiple times results in the same outcome.\nExample Use Case: Updating user profile information.\nupdated_data = {\u0026#34;title\u0026#34;: \u0026#34;Updated Post\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Updated content.\u0026#34;, \u0026#34;userId\u0026#34;: 1} response = requests.put(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;, json=updated_data) print(response.status_code) # 200 OK 4. DELETE Used to delete a resource from the server.\nExample Use Case: Removing a user’s account.\nresponse = requests.delete(\u0026#39;https://jsonplaceholder.typicode.com/posts/1\u0026#39;) print(response.status_code) # 200 OK or 204 No Content Python\u0026rsquo;s requests Library Python\u0026rsquo;s requests library simplifies HTTP requests with its user-friendly interface. It supports all common HTTP methods and provides functions to handle responses.\nKey Features:\nEasily send GET, POST, PUT, and DELETE requests. Handle JSON data seamlessly. Manage headers, query parameters, and authentication. Example:\nimport requests url = \u0026#39;https://api.example.com/resource\u0026#39; headers = {\u0026#39;Authorization\u0026#39;: \u0026#39;Bearer YOUR_TOKEN\u0026#39;} response = requests.get(url, headers=headers) if response.status_code == 200: print(\u0026#34;Request successful:\u0026#34;, response.json()) else: print(\u0026#34;Error:\u0026#34;, response.status_code) Conclusion Understanding HTTP requests and status codes is essential for working with web applications. The requests library in Python makes handling these requests straightforward, allowing developers to focus on building robust applications. By mastering methods like GET, POST, PUT, and DELETE, you can effectively interact with APIs and other web services.\n","permalink":"http://localhost:36779/posts/post_httprequests/","summary":"A Beginner\u0026rsquo;s Guide to HTTP Requests\nWhat Are HTTP Requests? HTTP (HyperText Transfer Protocol) is the foundation of communication on the web. When you access a website, your browser sends an HTTP request to the server hosting the site, and the server responds with the requested resources or an error message.\nHTTP requests are categorized into methods, and the server’s response includes status codes indicating the result of the request.","title":"A Beginner's Guide to HTTP Requests"},{"content":"A Beginner\u0026rsquo;s Guide to Regular Expressions in Python\nWhat Are Regular Expressions? Regular expressions, often abbreviated as regex or regexp, are patterns used to match sequences of characters in text. They are powerful tools for searching, extracting, and manipulating strings based on specific patterns. In Python, the re library is used to work with regular expressions, offering a range of functions to simplify text processing.\nWhen to Use Regular Expressions You should consider using regular expressions when:\nSearching for specific patterns in text (e.g., finding all dates in a document). Validating input formats (e.g., ensuring an email address is correctly formatted). Replacing or reformatting parts of text (e.g., converting snake_case to camelCase). Extracting data from unstructured text (e.g., pulling phone numbers from a webpage). However, regular expressions can be overkill for simple string operations. If basic string methods like .find(), .replace(), or .startswith() suffice, stick with those for better readability and performance.\nCommon Regular Expressions Used in Real Life Here are some commonly used regex patterns:\n1. Validating an Email Address import re email_pattern = r\u0026#39;^[\\w.%+-]+@[\\w.-]+\\.[a-zA-Z]{2,}$\u0026#39; email = \u0026#34;test@example.com\u0026#34; if re.match(email_pattern, email): print(\u0026#34;Valid email!\u0026#34;) else: print(\u0026#34;Invalid email!\u0026#34;) Explanation:\n^ and $: Ensure the pattern matches the entire string. [\\w.%+-]: Matches allowed characters in the username. @: Literal \u0026ldquo;@\u0026rdquo; symbol. [\\w.-]: Matches allowed characters in the domain name. \\.[a-zA-Z]{2,}: Matches a dot followed by at least two letters. 2. Finding All Phone Numbers text = \u0026#34;Call me at 123-456-7890 or 987.654.3210.\u0026#34; phone_pattern = r\u0026#39;\\b\\d{3}[-.]\\d{3}[-.]\\d{4}\\b\u0026#39; print(re.findall(phone_pattern, text)) Output: ['123-456-7890', '987.654.3210']\n3. Removing Extra Spaces text = \u0026#34;This is a test.\u0026#34; print(re.sub(r\u0026#39;\\s+\u0026#39;, \u0026#39; \u0026#39;, text)) Output: \u0026quot;This is a test.\u0026quot;\nRules for Creating Regular Expressions Special Characters: Regex includes special characters like ., , +, ?, ^, $, [ ], ( ), { }, and |. To match these literally, escape them with a backslash (\\). Character Classes: \\d: Matches any digit (0-9). \\w: Matches any word character (a-z, A-Z, 0-9, _) \\s: Matches any whitespace (spaces, tabs, newlines). [abc]: Matches any one of the characters a, b, or c. Quantifiers: : Matches 0 or more occurrences. +: Matches 1 or more occurrences. ?: Matches 0 or 1 occurrence. {n}: Matches exactly n occurrences. {n,}: Matches n or more occurrences. {n,m}: Matches between n and m occurrences. Anchors: ^: Matches the beginning of a string. $: Matches the end of a string. \\b: Matches a word boundary. Groups and Alternation: ( ): Groups patterns together. |: Acts as an OR operator. Sample Problem: Validating and Extracting Dates Problem: Write a Python function that validates a date in the format YYYY-MM-DD and extracts the year, month, and day if valid.\nSolution: import re def validate_and_extract_date(date): date_pattern = r\u0026#39;^(\\d{4})-(\\d{2})-(\\d{2})$\u0026#39; match = re.match(date_pattern, date) if match: year, month, day = match.groups() print(f\u0026#34;Valid date! Year: {year}, Month: {month}, Day: {day}\u0026#34;) else: print(\u0026#34;Invalid date format.\u0026#34;) validate_and_extract_date(\u0026#34;2024-12-31\u0026#34;) validate_and_extract_date(\u0026#34;31-12-2024\u0026#34;) Output:\nValid date! Year: 2024, Month: 12, Day: 31 Invalid date format. Conclusion Regular expressions are a versatile tool for text processing and validation in Python. By mastering the re library and understanding regex syntax, you can handle complex string operations efficiently. Just remember to use regex sparingly and not see it as a hammer sees nail scenario —simpler methods are often more readable for straightforward tasks.\n","permalink":"http://localhost:36779/posts/post_regex/","summary":"A Beginner\u0026rsquo;s Guide to Regular Expressions in Python\nWhat Are Regular Expressions? Regular expressions, often abbreviated as regex or regexp, are patterns used to match sequences of characters in text. They are powerful tools for searching, extracting, and manipulating strings based on specific patterns. In Python, the re library is used to work with regular expressions, offering a range of functions to simplify text processing.\nWhen to Use Regular Expressions You should consider using regular expressions when:","title":"Intro to Regex in Python"},{"content":"Positive News App - \u0026lsquo;Start The Ripple\u0026rsquo;\nVideo Demo: Description: This is a positive news application built with Python, Flask, HTML, CSS, Jinja, and multiple Python libraries and APIs. Its purpose is to deliver uplifting and inspiring news by aggregating articles and videos from various niches.\nPositive News Application\nThis is a positive news application built with Python, Flask, HTML, CSS, Jinja, and multiple Python libraries and APIs. Its purpose is to deliver uplifting and inspiring news by aggregating articles and videos from various niches.\nTable of Contents\nOverview Features APIs Used Challenges and Learning Installation Usage Limitations Future Plans Overview\nThe goal of this project was to create a web application that focuses on positive news across four key niches:\nTechnology Health Science Education Additionally, the project explores positive content on YouTube and summarizes it using AI. This was an ambitious project aimed at demystifying:\nAPI Integration: Understanding how to work with APIs to fetch, process, and display data. Web Deployment: Learning how to deploy a web application online. Features\nNews Aggregation: Fetches articles from 4 websites across the niches of Technology, Health, Science, and Education using the NewsAPI. Displays article titles and descriptions, with links to the original sources. YouTube Video Summaries: Fetches positive news videos in the same niches using the YouTube API. Retrieves video transcripts via a transcript API. Summarizes transcripts using the Hugging Face Transformer API. Clean and User-Friendly Design: Designed with Figma before implementation, emphasizing a polished and intuitive user experience (hopefully). APIs Used\nNewsAPI Fetches articles from major news outlets. Free tier limits to 4 niches to avoid costs and for pragmatic implementation. YouTube API Retrieves videos based on niche-related keywords (behind the scenes in the back-end). Transcript API Fetches manually or auto-generated transcripts (for videos without a transcript) for YouTube videos. Hugging Face Transformer API Summarizes video transcripts using the BART model. Free tier limits tokenization to ~1000 tokens per request. Challenges and Learning\nInitial Challenges:\nOvercoming uncertainty about API integration and web hosting. Managing the scope of the project to ensure it was challenging but doable. Key Learnings:\nAPI Integration: Learned to work with multiple APIs and process data for a real-world application. Cache Management Learned at a elementary level of how to cache the API results to reduce the number of API calls needed Web Deployment: Successfully hosted the project online, allowing external access to the application (Not meant for other uses as API costs are signicate outside of free tiers). Design Tools: Explored Figma for the first time, gaining insight into its value for front-end and UX design. Some Realizations\nThis project helped me realize the benefits and challenges of what developers often call a \u0026ldquo;band-aid\u0026rdquo; or \u0026ldquo;lego\u0026rdquo; approach—connecting APIs and libraries to build solutions. While this method is excellent for learning new tools and understanding what\u0026rsquo;s possible with code, relying on it too much could hinder a developer\u0026rsquo;s growth by minimizing the need for creative problem-solving. As a first-time experience, I found this approach both challenging and insightful. It pushed me to think creatively and revealed just how many tools are available for rapid prototyping and problem-solving. However, I also noticed the trade-offs: increased dependencies, a higher likelihood of issues arising, and the potential cost of relying heavily on third-party technologies. This project gave me valuable insights I wouldn’t have gained otherwise. Installation\nClone the repository:\ngit clone https://github.com/Fearfully-M/positive-news-app.git cd positive-news-app pip install -r requirements.txt\nSet up API Keys:\nObtain API kets for NewsAPI, YouTube API, and Hugging Face\nAdd them to an .env file:\nNEWS_API_KEY=your_news_api_key YOUTUBE_API_KEY=your_youtube_api_key HUGGINGFACE_API_KEY=your_huggingface_api_key Usage\nVisit the homepage to explore uplifting news from various niches. Click on an article to read more on the original source. Navigate to the YouTube page to find summarized videos via their transcripts. Limitations\nTokenization Limits:\nThe free tier of Hugging Face\u0026#39;s API limits summarization to ~1000 tokens (about 824 words per request). This affects summarization quality for long transcripts. Performance:\nUsing a cloud-based Hugging Face API results in slow loading times, especially on the YouTube page, where transcript summarization can several minutes depending on video transcipt size and the user\u0026#39;s computer\u0026#39;s GPU and CPU performance. Future Plans\nWeb Scraping: Incorporate web scraping for trending news stories. Trending News App: Streamline the application to focus on trending news rather than summarization, making it faster, more versatile, and more pragmatic for the average user. CLI Tool: Adapt the project into a command-line tool for personal use. Reflections and Gratitude\nThis project has been a significant learning experience, and I’m proud of what I’ve accomplished. Despite its limitations, it’s a functional application that tackles real-world challenges and demonstrates growth in API integration and deployment. Before doing the project I was completely mystified by how API\u0026rsquo;s worked, how to deploy a web application online, how Figma worked, and didn\u0026rsquo;t even know there were tier plans for APIs.\nThank you everyone who made CS50 and CS50X possible. I know you hear it all the time but it\u0026rsquo;s trully amazing that an education like this is available for free, on the internet, and can be accessed from anywhere. I always find it important to not become complacent in appreciating opprotunities like this because it can be easy to not realize how good most of us have things now and many, many people are never presented opprotunites like this and much less even take advantage of them. Thank you\n","permalink":"http://localhost:36779/portfolio/starttheripple/","summary":"Positive News App - \u0026lsquo;Start The Ripple\u0026rsquo;\nVideo Demo: Description: This is a positive news application built with Python, Flask, HTML, CSS, Jinja, and multiple Python libraries and APIs. Its purpose is to deliver uplifting and inspiring news by aggregating articles and videos from various niches.\nPositive News Application\nThis is a positive news application built with Python, Flask, HTML, CSS, Jinja, and multiple Python libraries and APIs. Its purpose is to deliver uplifting and inspiring news by aggregating articles and videos from various niches.","title":"News App Summarizer ('Start the Ripple')"},{"content":"Resume Keyword Analyzer\n#### Video Demo: \u0026lt;URL HERE\u0026gt; #### Description: A Python application that determines the ratio of keywords from a job description compared to a user\u0026#39;s resume text file Overview\nThe goal of this project was to enhance familiarity with Python and explore a couple of Python libraries through the development of a practical application.\nResume Keyword Analyzer is designed to help users optimize their resumes for specific job descriptions. It simplifies the process of identifying keyword matches between a resume and a job description, enabling users to refine their resumes to better align with individual job postings.\nFeatures\nKeyword Matching: Calculates the number of keywords in a resume relative to the keywords in a job description. Resume Input Options: Copy and paste the resume into a text box for immediate analysis. Open a .txt file of a resume to automatically save and display it in the resume text box. Resume Saving: Saves resumes for reuse without needing to re-enter them manually. Keyboard Shortcuts: Quickly copy and paste job descriptions with built-in shortcuts. Installation\nClone the repository:\ngit clone https://github.com/Fearfully-M/ResumeAnalyzer.git Install the required dependencies:\npip install -r requirements.txt Usage\nNavigate to the project\u0026rsquo;s main directory in your terminal.\nRun the application:\npy main.py Once the program launches:\nInput a job description of your choice into the Job Description text box. Use one of the following methods to input your resume: Copy and paste your resume into the Resume text box. Open a .txt file of your resume using the Open File option, which will automatically save and populate your resume in the text box. Click the Calculate button to determine the number of matching keywords between the job description and your resume. Libraries Used\n*CustomTkinter:** For creating the user interface. *nltk:** For processing text, including determining keywords and stopwords. Contributing\nIf you\u0026rsquo;d like to contribute to this project, feel free to fork the repository and submit a pull request. Contributions are welcome and appreciated!\nLicense\nThis project is licensed under the MIT License. See the LICENSE file for details.\nContact\nFor questions, feedback, or collaboration opportunities, feel free to reach out at [https://github.com/Fearfully-M].\nLet me know if you\u0026rsquo;d like any adjustments or additions!\n","permalink":"http://localhost:36779/portfolio/resumeanalyzer/","summary":"Resume Keyword Analyzer\n#### Video Demo: \u0026lt;URL HERE\u0026gt; #### Description: A Python application that determines the ratio of keywords from a job description compared to a user\u0026#39;s resume text file Overview\nThe goal of this project was to enhance familiarity with Python and explore a couple of Python libraries through the development of a practical application.\nResume Keyword Analyzer is designed to help users optimize their resumes for specific job descriptions.","title":"Resume Keyword Analyzer"},{"content":"1. What is a Virtual Environment? A Python virtual environment is a self-contained directory that includes its own Python interpreter and libraries. This setup is useful because it allows each project to use specific packages and versions without conflicts.\nFor example, you might have one project that requires Flask 1.1 and another that needs Flask 2.0. Virtual environments let you keep these projects separate.\n2. How to Create a Virtual Environment To create a virtual environment, use Python’s venv module.\nNavigate to your project directory (or any directory where you want to create the environment).\nCreate the virtual environment:\npython3 -m venv myenv This creates a folder named `myenv` (or any name you choose) in your directory. Inside this folder are directories for the Python interpreter, standard library, and any packages you install. 3. Activating the Virtual Environment To start using the virtual environment, you need to activate it. This changes your shell’s Python environment to the one inside the virtual environment.\nOn macOS/Linux:\nsource myenv/bin/activate When the environment is active, you’ll usually see the environment’s name in your terminal prompt, like (myenv), indicating that all Python commands (like python and pip) will use this environment.\n4. Installing Packages in a Virtual Environment With the virtual environment activated, you can install packages as usual with pip. For example:\npip install flask This installs flask only within the virtual environment and does not affect any system-wide installations.\nTo see all installed packages in the virtual environment, use:\npip list 5. Deactivating the Virtual Environment When you’re done working in the virtual environment, you can deactivate it to return to your system’s Python environment.\ndeactivate After running deactivate, the terminal prompt will return to normal, and Python commands will use the system’s Python again.\n6. When to Use Virtual Environments Use virtual environments whenever you:\nStart a new project: Isolate the project’s dependencies to avoid conflicts. Need specific versions of packages: Some projects require specific package versions, and a virtual environment lets you install them without affecting other projects. Want reproducible environments: Virtual environments help you manage dependencies so that other developers or environments can replicate your setup (e.g., by using a requirements.txt file). In a nutshell, virtual environments are helpful whenever you want to manage dependencies cleanly and keep projects isolated.\n7. Additional Tips Creating a requirements.txt file: Once you have all necessary packages in your virtual environment, create a requirements.txt file to record them. This allows others to install the same dependencies easily.\npip freeze \u0026gt; requirements.txt To install packages from a requirements.txt file in a new environment:\npip install -r requirements.txt Deleting a Virtual Environment: If you no longer need a virtual environment, simply delete its folder (myenv in this case), and it will be removed.\n8. Example Workflow Create the environment:\npython3 -m venv myenv Activate it:\nsource myenv/bin/activate Install packages: pip install flask Work on your project. Deactivate when done: deactivate ","permalink":"http://localhost:36779/posts/post_virtualenvironment/","summary":"1. What is a Virtual Environment? A Python virtual environment is a self-contained directory that includes its own Python interpreter and libraries. This setup is useful because it allows each project to use specific packages and versions without conflicts.\nFor example, you might have one project that requires Flask 1.1 and another that needs Flask 2.0. Virtual environments let you keep these projects separate.\n2. How to Create a Virtual Environment To create a virtual environment, use Python’s venv module.","title":"Creating Python Virtual Environments"}]